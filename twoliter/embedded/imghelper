#!/usr/bin/env bash

sanity_checks() {
  local output_fmt partition_plan ovf_template uefi_secure_boot
  output_fmt="${1:?}"
  partition_plan="${2:?}"
  ovf_template="${3:?}"
  uefi_secure_boot="${4:?}"
  case "${output_fmt}" in
  raw | qcow2 | vmdk) ;;
  *)
    echo "unexpected image output format '${output_fmt}'" >&2
    exit 1
    ;;
  esac

  case "${partition_plan}" in
  split | unified) ;;
  *)
    echo "unexpected partition plan '${partition_plan}'" >&2
    exit 1
    ;;
  esac

  # Fail fast if the OVF template doesn't exist, or doesn't match the layout.
  if [ "${output_fmt}" == "vmdk" ]; then
    if [ ! -s "${ovf_template}" ]; then
      echo "required OVF template not found: ${ovf_template}" >&2
      exit 1
    fi

    if [ "${partition_plan}" == "split" ]; then
      if ! grep -Fq '{{DATA_DISK}}' "${ovf_template}"; then
        echo "Missing data disk in OVF template, which is required for 'split' layout." >&2
        exit 1
      fi
    fi

    if [ "${partition_plan}" == "unified" ]; then
      if grep -Fq '{{DATA_DISK}}' "${ovf_template}"; then
        echo "Data disk included in OVF template, which is not supported for 'unified' layout." >&2
        exit 1
      fi
    fi

    if [ "${uefi_secure_boot}" == "yes" ]; then
      if ! grep -Fq '{{DB_CERT_DER_HEX}}' "${ovf_template}"; then
        echo "Missing CA certificate field in OVF template, which is required for Secure Boot support." >&2
        exit 1
      fi
    fi
  fi
}

# shellcheck disable=SC2034 # variables are used through parameter substitution
symlink_image() {
  local ext what target symlink_prefix version_id output_dir symlink_suffix
  ext="$1"
  what="${2:?}"
  symlink_prefix="${3:?}"
  version_id="${4:?}"
  output_dir="${5:?}"

  ext="${ext:+.$ext}"
  target="${what^^}_NAME"

  case "${what}" in
  os_image) symlink_suffix="" ;;
  data_image) symlink_suffix="-data" ;;
  boot_image) symlink_suffix="-boot.ext4.lz4" ;;
  verity_image) symlink_suffix="-root.verity.lz4" ;;
  root_image) symlink_suffix="-root.ext4.lz4" ;;
  *)
    echo "unknown image '${what}'" >&2
    exit 1
    ;;
  esac

  local symlink="${symlink_prefix}${symlink_suffix}"
  local versioned_symlink="${symlink_prefix}-${version_id}${symlink_suffix}"
  local friendly_versioned_symlink="${symlink_prefix}-v${version_id}${symlink_suffix}"

  for link in symlink versioned_symlink friendly_versioned_symlink; do
    ln -sf "${!target}${ext}" "${output_dir}/${!link}${ext}"
  done
}

# shim expects the following data structure in `.vendor_cert`:
#
# struct {
#   uint32_t vendor_authorized_size;
#   uint32_t vendor_deauthorized_size;
#   uint32_t vendor_authorized_offset;
#   uint32_t vendor_deauthorized_offset;
# } cert_table;
#
cert_table() {
  local input output size offset uint32_t
  input="${1:?}"
  output="${2:?}"
  size="$(stat -c %s "${input}")"
  rm -f "${output}"
  # The cert payload is offset by four 4-byte uint32_t values in the header.
  offset="$((4 * 4))"
  for n in "${size}" 0 "${offset}" "$((size + offset))"; do
    printf -v uint32_t '\\x%02x\\x%02x\\x%02x\\x%02x' \
      $((n & 255)) $((n >> 8 & 255)) $((n >> 16 & 255)) $((n >> 24 & 255))
    # shellcheck disable=SC2059  # Variable contains a pattern
    printf "${uint32_t}" >>"${output}"
  done
  cat "${input}" >>"${output}"
  # Zero-pad the output to the expected section size. Otherwise a subsequent
  # `objcopy` operation on the same section might fail to replace it, if the
  # new vendor certificate is larger than this one.
  truncate -s 4096 "${output}"
}

# Helper functions to log the object layout before and after changes.
aarch64-objdumpcopy() {
  local obj
  obj="${1:?}"
  aarch64-bottlerocket-linux-gnu-objdump -h "${obj}"
  aarch64-bottlerocket-linux-gnu-objcopy "${@}" "${obj}"
  aarch64-bottlerocket-linux-gnu-objdump -h "${obj}"
}

x86_64-objdumpcopy() {
  local obj
  obj="${1:?}"
  x86_64-bottlerocket-linux-gnu-objdump -h "${obj}"
  x86_64-bottlerocket-linux-gnu-objcopy "${@}" "${obj}"
  x86_64-bottlerocket-linux-gnu-objdump -h "${obj}"
}

mkfs_data_ext4() {
  local target size offset bottlerocket_data data_mount unlabeled
  target="${1:?}"
  size="${2:?}"
  offset="${3:?}"
  bottlerocket_data="${4:?}"
  data_mount="${5:?}"
  unlabeled="${6:?}"
  echo "writing ext4 filesystem for DATA"
  mkfs.ext4 -m 0 -d "${data_mount}" "${bottlerocket_data}" "${size}"
  echo "${unlabeled}" | debugfs -w -f - "${bottlerocket_data}"
  dd if="${bottlerocket_data}" of="${target}" conv=notrunc bs=1M seek="${offset}"
}

mkfs_data_xfs() {
  local target size offset bottlerocket_data data_mount unlabeled
  target="${1:?}"
  size="${2:?}"
  offset="${3:?}"
  bottlerocket_data="${4:?}"
  data_mount="${5:?}"
  unlabeled="${6:?}"
  echo "writing blank partition for DATA"
  # Create a file to write the filesystem to first
  dd if=/dev/zero of="${bottlerocket_data}" bs=1M count="${size%?}"
  dd if="${bottlerocket_data}" of="${target}" conv=notrunc bs=1M seek="${offset}"
}

generate_ova() {
  local os_vmdk data_vmdk
  os_vmdk="${1:?}"
  data_vmdk="${2:?}"

  local os_image_publish_size_gib data_image_publish_size_gib
  os_image_publish_size_gib="${3:?}"
  data_image_publish_size_gib="${4:?}"

  local ovf_template uefi_secure_boot sbkeys output_dir
  ovf_template="${5:?}"
  uefi_secure_boot="${6:?}"
  sbkeys="${7:?}"
  output_dir="${8:?}"

  local ova_dir
  ova_dir="$(mktemp -d)"

  local file_prefix="${os_vmdk%.vmdk}"
  local ovf="${file_prefix}.ovf"

  # The manifest expects disk sizes in bytes.
  local bytes_in_gib os_disk_bytes data_disk_bytes
  bytes_in_gib="$((1024 * 1024 * 1024))"
  os_disk_bytes="$((os_image_publish_size_gib * bytes_in_gib))"
  data_disk_bytes="$((data_image_publish_size_gib * bytes_in_gib))"
  sed "${ovf_template}" \
    -e "s/{{OS_DISK}}/${os_vmdk}/g" \
    -e "s/{{DATA_DISK}}/${data_vmdk}/g" \
    -e "s/{{OS_DISK_BYTES}}/${os_disk_bytes}/g" \
    -e "s/{{DATA_DISK_BYTES}}/${data_disk_bytes}/g" \
    >"${ova_dir}/${ovf}"

  # The manifest templates for Secure Boot expect the cert data for
  # PK, KEK, db, and dbx.
  if [[ "${uefi_secure_boot}" == "yes" ]]; then
    local data_disk_bytes kek_cert_der_hex db_cert_der_hex dbx_empty_hash_hex
    pk_cert_der_hex="$(hexdump -ve '1/1 "%02x"' "${sbkeys}/PK.cer")"
    kek_cert_der_hex="$(hexdump -ve '1/1 "%02x"' "${sbkeys}/KEK.cer")"
    db_cert_der_hex="$(hexdump -ve '1/1 "%02x"' "${sbkeys}/db.cer")"
    dbx_empty_hash_hex="$(sha256sum /dev/null | awk '{ print $1 }')"
    sed -i \
      -e "s/{{PK_CERT_DER_HEX}}/${pk_cert_der_hex}/g" \
      -e "s/{{KEK_CERT_DER_HEX}}/${kek_cert_der_hex}/g" \
      -e "s/{{DB_CERT_DER_HEX}}/${db_cert_der_hex}/g" \
      -e "s/{{DBX_EMPTY_HASH_HEX}}/${dbx_empty_hash_hex}/g" \
      "${ova_dir}/${ovf}"
  fi

  # Make sure we replaced all the '{{...}}' fields with real values.
  if grep -F -e '{{' -e '}}' "${ova_dir}/${ovf}"; then
    echo "Failed to fully render the OVF template" >&2
    exit 1
  fi

  # Create the manifest file with the hashes of the VMDKs and the OVF.
  local os_sha256 data_sha256 ovf_sha256
  local manifest="${file_prefix}.mf"
  pushd "${output_dir}" >/dev/null || exit 1
  os_sha256="$(sha256sum "${os_vmdk}" | awk '{print $1}')"
  echo "SHA256(${os_vmdk})= ${os_sha256}" >"${ova_dir}/${manifest}"
  if [[ -s "${data_vmdk}" ]]; then
    data_sha256="$(sha256sum "${data_vmdk}" | awk '{print $1}')"
    echo "SHA256(${data_vmdk})= ${data_sha256}" >>"${ova_dir}/${manifest}"
  fi
  popd >/dev/null || exit 1
  pushd "${ova_dir}" >/dev/null || exit 1
  ovf_sha256="$(sha256sum "${ovf}" | awk '{print $1}')"
  echo "SHA256(${ovf})= ${ovf_sha256}" >>"${manifest}"
  popd >/dev/null || exit 1

  # According to the OVF spec:
  # https://www.dmtf.org/sites/default/files/standards/documents/DSP0243_2.1.1.pdf,
  # the OVF must be first in the tar bundle.  Manifest is next, and then the
  # files must fall in the same order as listed in the References section of the
  # OVF file
  local ova="${file_prefix}.ova"
  tar -cf "${output_dir}/${ova}" -C "${ova_dir}" "${ovf}" "${manifest}"
  tar -rf "${output_dir}/${ova}" -C "${output_dir}" "${os_vmdk}"
  if [[ -s "${data_vmdk}" ]]; then
    tar -rf "${output_dir}/${ova}" -C "${output_dir}" "${data_vmdk}"
  fi

  rm -rf "${ova_dir}"
}
